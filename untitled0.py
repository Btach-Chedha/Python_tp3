# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AHh71AUnLAh7Qz04-TYocN0JLMvi2M6X

# **Advanced Python**

**1-Pydantic**

*1.1-Python’s Dynamic Typing Problem*

1.1.1-Creation texte en gras a variable you don’t have to declare it is type
"""

# Python
x = 10

"""1.1.2-Override variable with a different type:"""

x = 10
x = 'hello'

"""1.1.3-The Hidden Costs of Python’s Dynamic Typing:"""

ali = Person("Ali", 24)    # Correct
ali = Person("Ali", "24")  # Mistake

"""1.2-How To Use Pydantic:

1.2.1-Install :
"""

pip install pydantic

"""1.2.2-Define a class that inherits from the BaseModel class:"""

from pydantic import BaseModel

class User(BaseModel):
    name: str
    email: str
    account_id: int

"""1.2.3-Exemple:"""

user = User(
    name = "Salah",
    email = "salah@gmail.com",
    account_id = 12345
)

"""1.2.4-Another way to create an instance of the model by unpacking a dictionary:"""

user_data = {
    'name': 'Salah',
    'email': 'salah@gmail.com',
    'account_id': 12345
}

user = User(**user_data)

"""1.2.5-If the data that you have passed in is valid, then the user object will be successfully created:"""

print(user.name)    # Salah
print(user.email)    # salah@gmail.com
print(user.account_id)    # 12345

"""1.3-Validating Data with Pydantic:

1.3.1-creation a user with an account_id :
"""

from pydantic import BaseModel

class User(BaseModel):
    name: str
    email: str
    account_id: int

# It will fail and show a validation error
user = User(name = 'Ali', email = 'ali@gmailcom', account_id = 'hello')
print(user)

"""**L'erreur:** account_id est de type int

**La solution:** Il faut changer la valeur donnée pour account_id

"""

from pydantic import BaseModel

class User(BaseModel):
    name: str
    email: str
    account_id: int

user = User(name = 'Ali', email = 'ali@gmailcom', account_id = 12345)
print(user)

"""1.3.2-Validate that the email attribut of User class is an email:"""

from pydantic import BaseModel, EmailStr

class User(BaseModel):
    name: str
    email: EmailStr     # pip install pydantic[email]
    account_id: int

# It will fail and show a validation error with email = 'ali'
user = User(name = 'Ali', email = 'ali', account_id = 1234)
print(user)

"""**L'erreur:** Monque de l'installation de  pydantic[email] et email de type EmailStr

**La solution:** Il faut installer  pydantic[email] et  changer la valeur donnée pour email
"""

pip install pydantic[email]

from pydantic import BaseModel, EmailStr

class User(BaseModel):
    name: str
    email: EmailStr
    account_id: int

user = User(name="Ali", email="ali@gmail.com", account_id=12345)
print(user)

"""1.4-Custom Field Validation:

1.4.1-Validation logic to your model:
"""

@field_validator("account_id")
def validate_account_id(cls, value):
    if value <= 0:
        raise ValueError(f"account_id must be positive: {value}")
    return value

"""1.4.2-Example with a negative account_id, you will get a validation error:"""

# you will get a validation error with account_id = -12
user = User(name = 'Ali', email = 'ali', account_id = -12)
print(user)

"""**L'erreur:** account_id a une valeur negative et email a un valeur deffirent de EmailStr

**La solution:** Il faut changer la valeur par une autre positive et changer la valeur donée pour email
"""

user = User(name = 'Ali', email = 'ali@gmail.com', account_id = 12)
print(user)

"""1.5-JSON Serialization :

1.5.1-Convert a Pydantic model to JSON:
"""

user_json_str = user.model_dump_json()
# this will return a JSON strinf representation of the model's data
print(user_json_str)

"""1.5.2-Use the model_dump method:"""

user_json_obj = user.model_dump()

"""1.5.3-Use the parse_raw() method"""

json_str = {"name": "Ali, "email": "ali@gmail.com", "account_id": 1234}
user = user.parse_raw(json_str)

"""**L'erreur:**SyntaxError (guillemet manquant après "Ali) et NameError (user non défini avant utilisation).

**La solution:**Ajoutez le guillemet manquant ("name": "Ali") et utilisez User.parse_raw() (classe) au lieu de user.parse_raw().
"""

from pydantic import BaseModel
import json

class User(BaseModel):
    name: str
    email: str
    account_id: int

json_str = '{"name": "Ali", "email": "ali@gmail.com", "account_id": 1234}'

user = User.parse_raw(json_str)

print(user)

"""1.6-Pydantic vs Dataclasses:

1.6.1-Specify type hints like the following code:
"""

# Python 3.6+
x: int = 0
y: str = "hello"

"""1.6.2-Create a class with fields:"""

from dataclasses import dataclass

@dataclass
class User:
    name: str
    email: str
    account_id: int

"""**2-Requests:**

2.1-GET Request:

2.1.1-Install  Requests Python module:
"""

pip install requests

"""2.1.2.1-Make a simple GET request to a website:"""

import requests

url = "https://www.example.com"
response = requests.get(url)

"""2.1.2.2-To show the result:"""

# it will show the HTTP status code
print(response)

"""2.2-HTTP Status Codes:

2.2.1-To get the status code attribute of the response object:
"""

print(response.status_code)

"""2.3-Request Content:

2.3.1-To show the response content:
"""

import requests

response = requests.get("https://www.example.com")
print(repsonse.content)

"""**L'erreur:**La variable repsonse introuvable (qui n'existe pas).


**La solution:**Changer par la variable correcte est response.
"""

import requests

response = requests.get("https://www.example.com")
print(response.content)

"""2.4-POST Request:

2.4.1-Create a post or submit a blog:
"""

data = {"name": "Salah", "message": "Hello!"}
url = "https://httpbin.org/post"

response = requests.post(url, json=data)

"""2.4.2-Use json() method on the response object:"""

response_data = response.json()
# Shows the data as a dictionary
print(response_data)

"""2.5-Handling Errors

2.5-To check for error codes using the status code:
"""

import requests

# here we use an endpoint that always gives a 404 status error
response = requests.get("https://httpbin.org/status/404")
# if status code is not 200 (successful response), then show error message
if response.status_code != 200:
    print(f"HTTP Error: {response.status_code}")

"""2.6-Setting a Timeout:

2.6.1-Pass the timeout parameter to the request method:
"""

url = "https://httpbin.org/delay/10"

try:
    response = requests.get(url, timeout=5)
except requests.exceptions.Timeout as err:
    print(err)

"""2.7-HTTP Request Headers:

2.7.1-Create a dictionary with the headers values you want to use:
"""

auth_token = "XXXXXXXX"

# here we set the authorization header with the 'bearer token' for authentication purposes.
headers = {
    "Authorization": f"Bearer {auth_token}"
}

url = "https://httpbin.org/headers"
response = requests.get(url, headers=headers)
print(response.json())

"""2.8-Web Scraping with BeautifulSoup:

2.8-Use the get request method to receive the raw HTML content of the page:

2.8.1-Use the get request method to receive the raw HTML content of the page:
"""

import requests

url = "https://www.example.com"
# this will get all the HTML, javascript, css code
response = requests.get(url)

"""2.8.2-Use another module called BeautifulSoup:"""

pip install beautifulsoup4

"""2.8.3-Make searching and traversing the HTML content much easier:"""

import requests
from bs4 import BeautifulSoup

url = "https://www.example.com"
response = requests.get(url)
soup = BeautifulSoup(response.content, "html.parser")

"""2.8.4-Exemple:"""

title = soup.title.text
content = soup.find("p").text
links = [a["href"] for a in soup.find_all("a")]

print(title, content, links)

"""2.9-Requests vs urllib:

2.9.1-Example post request in urllib:
"""

import urllib.request
import urllib.parse

data = urllib.parse.urlencode({"key"; "value"}).encode("utf-8")
req = urllib.request.Request("https://www.example.com", data=data, method="post")
with urllib.request.urlopen(req) as response:
    html = response.read().decode("utf-8")
print(html)

"""**L'ereur:**Utilisation d'un point-virgule (;) au lieu de deux-points (:) dans le dictionnaire.

**La solution:**Remplacez {"key"; "value"} par {"key": "value"}.
"""

import urllib.request
import urllib.parse

url = "https://www.example.com"
data = urllib.parse.urlencode({"key": "value"}).encode("utf-8")


headers = {
    "User-Agent": "Mozilla/5.0"
}

req = urllib.request.Request(url, data=data, headers=headers, method="POST")

try:
    with urllib.request.urlopen(req) as response:
        html = response.read().decode("utf-8")
    print(html)
except urllib.error.HTTPError as e:
    print(f"HTTP Error: {e.code} - {e.reason}")
except urllib.error.URLError as e:
    print(f"URL Error: {e.reason}")

"""**3-FastAPI:**

3.1-Install and Get Started with FastAPI:

3.1.1-Install:
"""

pip install fastapi uvicorn

"""3.1.2-Create a new directory for the project and create a file named main.py :"""

from fastapi import FastAPI

# Create an app
app = FastAPI()

# define a path for HTTP Get method
@app.get("/")
def root():
    return {"Hello": "World"}

"""3.1.3-Use uvicron in the terminal:"""

uvicorn main:app --reload

"""**L'erreur :** Monque de l'importation

 **La solution:** Ajout de l'importation
"""

import uvicorn
uvicorn.run("main:app", reload=True)

"""3.2-GET and POST Routes:

3.2.1-Create an empty list of items:
"""

items = []

"""3.2.2-Create a new endpoint for our app:"""

@app.post("items")
def create_item(item: str):
    items.append(item)
    return item

"""3.2.3-Test the endpoint:"""

curl -X POST -H "Content-Type: application/json" 'http://127.0.0.1:8000/items?item=apple'

"""**L'erreur :** Tu as tapé une commande `curl` dans un bloc Python, ce qui provoque une erreur de syntaxe.  
**La solution :** Ajoute un `!` devant la commande `curl` pour l’exécuter dans le terminal Colab.
"""

!curl -X POST -H "Content-Type: application/json" "http://127.0.0.1:8000/items?item=apple"

"""3.2.4-Create an endpoint to view a specific item of the list:"""

@app.get("items/{item_id}")
def get_item(item_id: int) -> str:
    item = items[item_id]
    return item

"""3.2.5-Test the endpoint:"""

curl -X GET http://127.0.0.1:8000/items/0

"""**L'erreur** : `SyntaxError: invalid syntax` car `curl` est une commande shell, pas du Python.  
**La solution** : ajouter `!` devant la commande : `!curl -X GET http://127.0.0.1:8000/items/0`.
"""

!curl -X GET http://127.0.0.1:8000/items/0

"""3.2.6-Try to get an item that doesn’t exist:"""

curl -X GET http://127.0.0.1:8000/items/7

"""**L'erreur:**invalid syntax car curl est une commande shell, pas du Python.  l'absence du ! pour exécuter une commande système

**La solution:** ajouter ! devant la commande


"""

!curl -X GET http://127.0.0.1:8000/items/7

"""3.3-Handling HTTP Errors:

3.3.1-Import HTTPException from FastAPI:
"""

from fastapi import FastAPI, HTTPException

"""3.3.2-Modify the get_item() endpoint to use the HTTPException:"""

@app.get("items/{item_id}")
def get_item(item_id: int) -> str:
    if item_id < len(items):
        return = items[item_id]
    else:
        raise HTTPException(status_code=404, detail=f"Item {item_id} not found")

"""**L'erreur: **`return =` est incorrect, il faut simplement utiliser `return`.  
**La solution:** Remplacez `return = items[item_id]` par `return items[item_id]`.
"""

from fastapi import FastAPI, HTTPException

app = FastAPI()

items = ["item1", "item2", "item3"]  # Exemple de liste d'items

@app.get("/items/{item_id}")
def get_item(item_id: int) -> str:
    if item_id < len(items):
        return items[item_id]
    else:
        raise HTTPException(status_code=404, detail=f"Item {item_id} not found")

"""3.3.3-Run the same request again:"""

curl -X GET http://127.0.0.1:8000/items/7

"""**L'erreur :** Tu as tapé une commande `curl` dans un bloc Python, ce qui provoque une erreur de syntaxe.  
**La solution :** Ajoute un `!` devant la commande `curl` pour l’exécuter dans le terminal Colab.
"""

!curl -X GET http://127.0.0.1:8000/items/7

"""3.4-JSON Request and Path Parameters:

3.4.1-Create a new endpoint called list_items:
"""

# this endpoint uses a query parameter 'limit'
@app.get("/items/")
def list_items(limit: int = 10):
    return items[0:limit]

"""Test this endpoint (first add at least 10 items to the list):"""

curl -X GET 'http://127.0.0.1:8000/items?limit=3'

"""**L'erreur :** Tu as tapé une commande `curl` dans un bloc Python, ce qui provoque une erreur de syntaxe.  
**La solution :** Ajoute un `!` devant la commande `curl` pour l’exécuter dans le terminal Colab.
"""

!curl -X GET 'http://127.0.0.1:8000/items?limit=3'

"""3.5-Pydantic models:

3.5.1-Import BaseModel from Pydantic:
"""

from pydantic import BaseModel

"""3.5.2-Create an item class:"""

class Item(BaseModel):
    text: str = None
    is_done: bool = False

"""3.5.3-Update the app:"""

...
def create_item(item: Item):
...
def get_item(item_id: int) -> Item:

"""**L'erreur** : Les fonctions `create_item` et `get_item` ne sont pas associées à des routes FastAPI.  
**La solution** : Ajouter les décorateurs `@app.post(...)` et `@app.get(...)` pour exposer les fonctions comme endpoints.
"""

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    text: str = None
    is_done: bool = False

@app.post("/items/")
def create_item(item: Item):
    return {"message": "Item created", "item": item}

@app.get("/items/{item_id}", response_model=Item)
def get_item(item_id: int):
    # Exemple fictif de récupération d’un item (à adapter selon ta logique)
    return Item(text=f"Item {item_id}", is_done=False)

"""3.5.4-Test the create_item endpoint:"""

curl -X POST -H "Content-Type: application/json" 'http://127.0.0.1:8000/items?item=apple'

"""**L'erreur :** Tu as tapé une commande `curl` dans un bloc Python, ce qui provoque une erreur de syntaxe.  
**La solution :** Ajoute un `!` devant la commande `curl` pour l’exécuter dans le terminal Colab.
"""

!curl -X POST -H "Content-Type: application/json" 'http://127.0.0.1:8000/items?item=apple'

"""use:"""

curl -X POST -H "Content-Type: application/json" -d '{"text":"apple"}' 'http://127.0.0.1:8000/items'

"""**L'erreur :** Tu as tapé une commande `curl` dans un bloc Python, ce qui provoque une erreur de syntaxe.  
**La solution :** Ajoute un `!` devant la commande `curl` pour l’exécuter dans le terminal Colab.
"""

!curl -X POST -H "Content-Type: application/json" -d '{"text":"apple"}' 'http://127.0.0.1:8000/items'

"""3.5.5-Change the text attribute of the Item class:"""

class Item(BaseModel):
    # without default value
    text: str
    is_done: bool = False

"""3.5.6-Add an item without a text value like the following:"""

curl -X POST -H "Content-Type: application/json" -d '{"title":"apple"}' 'http://127.0.0.1:8000/items'

"""**L'erreur :** Tu as tapé une commande `curl` dans un bloc Python, ce qui provoque une erreur de syntaxe.  
**La solution :** Ajoute un `!` devant la commande `curl` pour l’exécuter dans le terminal Colab.
"""

!curl -X POST -H "Content-Type: application/json" -d '{"title":"apple"}' 'http://127.0.0.1:8000/items'

"""3.6-Response Models:

3.6.1-Update the app:
...
"""

...
# Specify the response type will be a list of Item
@app.get("/items", response_model=list[Item])
def list_item(limit: int = 10):
...
# Specify the response type will be an Item model
@app.get("/items/{item_id}", response_model=Item)
def get_item(item_id: int) -> Item:

"""**L'rreur :** Le type de retour `-> Item` cause une redondance ou une erreur si `Item` n’est pas encore défini.  
**La solution :** Supprimer `-> Item` et se fier uniquement à `response_model=Item` pour définir la réponse.
"""

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    text: str = None
    is_done: bool = False

# Specify that the response will be a list of Item
@app.get("/items", response_model=list[Item])
def list_item(limit: int = 10):
    return [Item(text=f"Item {i}", is_done=bool(i % 2)) for i in range(limit)]

# Specify that the response will be a single Item
@app.get("/items/{item_id}", response_model=Item)
def get_item(item_id: int):
    return Item(text=f"Item {item_id}", is_done=False)

"""**4-Streamlit:**

4.1-What is Streamlit?:

4.1.1-Install:
"""

pip install streamlit

"""4.1.2-Test it:"""

import streamlit as st

st.write('Hello World')

"""4.1.3-Example:"""

streamlit run main.py

from fastapi import FastAPI, Request

app = FastAPI()

@app.post("/items")
async def create_item(request: Request):
    body = await request.json()
    params = request.query_params
    return {"body": body, "query_params": dict(params)}

"""4.1.4-Add a text input:"""

st.text_input('Favorite Movie?')

"""4.2-Using Input Elements:

4.2.1-Exemple of different input elements you can use:
"""

# this capture the return value into x
x = st.text_input('Favorite Movie?')

st.write(f"Your favorite movie is: {x}")

x = st.text_input('Favorite Movie?')
st.write(f"Your favorite movie is: {x}")

"""4.2.2-Create buttons:"""

is_clicked = st.button("Click Me")

"""4.2.3-Example of Streamlit supports Markdown formatting by default:"""

import streamlit as st

st.write("## This is a H2 Title!")

st.markdown("*Streamlit* is **really** ***cool***.")
st.markdown('''
    :red[Streamlit] :orange[can] :green[write] :blue[text] :violet[in]
    :gray[pretty] :rainbow[colors] and :blue-background[highlight] text.''')
st.markdown("Here's a bouquet &mdash;\
            :tulip::cherry_blossom::rose::hibiscus::sunflower::blossom:")

multi = '''If you end a line with two spaces,
a soft return is used for the next line.

Two (or more) newline characters in a row will result in a hard return.
'''
st.markdown(multi)

"""4.3-Working with Data:

4.3.1-CSV file (movies.csv contain different movies available on Netflix):
"""

import pandas as pd

data = pd.read_csv("movies.csv")
# This shows the data in a nice table
st.write(data)  # display the data inside the app

"""4.3.2-Show your data in a graph:"""

import numpy as np

# Some random generated data
chart_data = pd.DataFrame(
    np.random.randn(20, 3),
    columns=["a", "b", "c"]
)

st.bar_chart(chart_data)
st.line_chart(chart_data)

"""4.4-Loan Repayments App:

4.4.1-Build a Loan Repayments Calculator to put in practise all of this:
"""

import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import math

st.title("Mortgage Repayments Calculator")

st.write("### Input Data")
col1, col2 = st.columns(2)  # Display elements in 2 column using the column component
# Set a default value or minimum/maximum value
home_value = col1.number_input("Home Value", min_value=0, value=500000)
deposit = col1.number_input("Deposit", min_value=0, value=100000)
interest_rate = col2.number_input("Interest Rate (in %)", min_value=0.0, value=5.5)
loan_term = col2.number_input("Loan Term (in years)", min_value=1, value=30)

# Calculate the repayments.
loan_amount = home_value - deposit
monthly_interest_rate = (interest_rate / 100) / 12
number_of_payments = loan_term * 12
monthly_payment = (
    loan_amount
    * (monthly_interest_rate * (1 + monthly_interest_rate) ** number_of_payments)
    / ((1 + monthly_interest_rate) ** number_of_payments - 1)
)

# Display the repayments.
total_payments = monthly_payment * number_of_payments
total_interest = total_payments - loan_amount

st.write("### Repayments")
col1, col2, col3 = st.columns(3)    # Create 3 columns
col1.metric(label="Monthly Repayments", value=f"${monthly_payment:,.2f}")
col2.metric(label="Total Repayments", value=f"${total_payments:,.0f}")
col3.metric(label="Total Interest", value=f"${total_interest:,.0f}")


# Create a data-frame with the payment schedule.
schedule = []
remaining_balance = loan_amount

for i in range(1, number_of_payments + 1):
    interest_payment = remaining_balance * monthly_interest_rate
    principal_payment = monthly_payment - interest_payment
    remaining_balance -= principal_payment
    year = math.ceil(i / 12)  # Calculate the year into the loan
    schedule.append(
        [
            i,
            monthly_payment,
            principal_payment,
            interest_payment,
            remaining_balance,
            year,
        ]
    )

df = pd.DataFrame(
    schedule,
    columns=["Month", "Payment", "Principal", "Interest", "Remaining Balance", "Year"],
)

# Display the data-frame as a chart.
st.write("### Payment Schedule")
payments_df = df[["Year", "Remaining Balance"]].groupby("Year").min()
st.line_chart(payments_df)

"""4.5-Deploying to Streamlit Cloud:"""

pip freeze > requirements.txt